#pragma once

#include "TeCorePrerequisites.h"
#include "Importer/TeImportOptions.h"
#include "Image/TePixelData.h"

namespace te
{
    /** Contains import options you may use to control how is a texture imported. */
    class TE_CORE_EXPORT TextureImportOptions : public ImportOptions
    {
    public:
        TextureImportOptions();

        /** Pixel format to import as. */
        PixelFormat Format = Util::IsBigEndian() ? PF_RGBA8 : PF_BGRA8;

        /** Enables or disables mipmap generation for the texture. */
        bool GenerateMips = false;

        /** If mipmap generation is enabled, try to load them on GPU with fallback to CPU. */
        bool GenerateMipsOnGpu = true;

        /** Enable this to rescale the alpha values of computed mipmaps so coverage is preserved. 
         * This means a higher percentage of pixels passes the alpha test and lower mipmap levels do not become more transparent  
         */
        bool MipsPreserveCoverage = false;

        /** Maximum mip level to generate when generating mipmaps. If 0 then maximum amount of mip levels will be generated. */
        UINT32 MaxMip = 0;

        /**
         * Determines whether the texture data should be treated as if its in sRGB (gamma) space. Such texture will be
         * converted by hardware to linear space before use on the GPU.
         */
        bool SRGB = false;

        /** Determines whether the texture data is also stored in main memory, available for fast CPU access. */
        bool CpuCached = false;

        /**
         * Determines should the texture be imported as a normal map. 
         * If the input image is a normal map, it may require some special treatment. For example, gamma correction won't be applied, 
         * and some operations will only be active for normal maps. To indicate that the input image is a normal map the following method is used:
         * [Only for CPU mipmaps generation] Normal map mipmaps are generated by down filtering the previous normal map level, 
         * just like with regular images. However, after down filtering the resulting normals are generally not unit length. These normals are re-normalized
         */
        bool IsNormalMap = false;

        /**
         * Determines should the texture be imported as a cubemap. See setCubemapSource to choose how will the source
         * texture be converted to a cubemap.
         */
        bool IsCubeMap = false;

        CubemapSourceType CubemapType = CubemapSourceType::Faces;

        /** Creates a new import options object that allows you to customize how are textures imported. */
        static SPtr<TextureImportOptions> Create();
    };
}
